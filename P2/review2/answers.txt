Task 1

c)
-  adds well-known, traditional imperative constructs
-  Using SOIL, imperative definitions can be given for the operations of a model, and the imperative definitions can be validated against the
   structural and dynamic constraints of the model
-  in contrast to other similiar approaches, the syntax and semantics of OCL remains unchanged by SOIL
-  operations can be described in a declarative way and in an operational way on the modeling level without going into the details of 
   a conventional programming language

d)
(SOIL is a great language that enables the reuse of existing tools and libraries, of knowledge that developer already gained for OCL,
and of formal methodsfor OCL expressions.)
The drawback of SOIL is the amalgamation of expressions and statements with regard to monolithic languages such as ImperativeOCL, where constructs have to decomposed in SOIL resulting in larger programs. Solution -> ?




Task 2

1)
-- Specification: Write an operation that counts the number of employees
-- in a Department
-- Solution:
numberOfEmployees() : Integer = self.employee->size()

2) 
-- Specification: Write an operation that remove an employee from a Department
-- and also from all Projects of that Department
-- Solution:
leave(e:Employee) begin
    delete(e,self) from WorksIn;
    for p in e.project do
      delete (e,p) from WorksOn;
    end   
end

3) 
-- Specification: Write an operation that add an Employee to a Project
-- Solution:
addMembers(p:Project,e:Employee) begin
    insert(e,p) into WorksOn;
end
