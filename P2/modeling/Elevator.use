model ElevatorModel

-- classes

class Controller
attributes
  deltaT : Real
  deltaZ : Real
operations
  control() begin
    for e in Elevator.allInstances() do
      declare floors : Sequence(Floor),
              atFloor : Floor;
      floors := (e.floorButton->select(fb|fb.pressed).destFloor->
      union(e.downButton->select(db|db.pressed).downOnFloor)->
      union(e.upButton->select(ub|ub.pressed).upOnFloor))->asSequence;
      atFloor := floors->select(fl|(e.z-fl.z).abs<=self.deltaZ)->at(1);
      if e.person.weight->sum > e.maxLoad then
        e.beeping := true;
      else e.beeping:=false
      end;
      if atFloor<>null or e.doors->exists(d|d.state=#closing) then
        for door in e.doors do
          if atFloor=door.floor and not e.doors->exists(d|d.state=#closing) then
            if e.beeping=false and (door.state=DoorsState::closed or door.state=#opening) then
              e.brake:=true;
              door.command:=#open
            end            
          end;
          if e.beeping=false and door.state=#closing then
            door.command:=#close;
            e.direction:=#idle
          end;
          if e.beeping=false and door.state=DoorsState::open and atFloor=door.floor then
            door.command:=#close;
            for ub in atFloor.upButton->select(ub|(e.z-ub.upOnFloor.z).abs<=self.deltaZ) do
              ub.pressed:=false
            end;
            for db in atFloor.downButton->select(db|(e.z-db.downOnFloor.z).abs<=self.deltaZ) do
              db.pressed:=false
            end;
            for fb in atFloor.floorButton->select(fb|(e.z-fb.destFloor.z).abs<=self.deltaZ) do
              fb.pressed:=false
            end
          end            
        end
      end;
      if e.direction<>#idle and atFloor=null and
      e.doors->forAll(d|d.state=DoorsState::closed) then
        e.direction:=e.direction
      end;
      if e.direction=#idle and e.z<floors->first.z and
      atFloor=null and e.doors->forAll(d|d.state=DoorsState::closed) then
        e.brake:=false;
        e.direction:=#up
      end;
      if e.direction=#idle and e.z>floors->first.z and
      atFloor=null and e.doors->forAll(d|d.state=DoorsState::closed) then
        e.brake:=false;
        e.direction:=#down
      end;
      if (floors->isEmpty) and
      e.doors->forAll(door|door.state=#closed) then
        e.direction:=#idle
      end
    end      
  end
end

-- liste von 

abstract class Location
end

class Floor < Location
attributes
  z : Real
  height : Real
operations
  abovePlus() : Set(Floor) =
    abovePlusAux(Set{above})->reject(isUndefined)

  belowPlus() : Set(Floor) = 
    belowPlusAux(Set{below})->reject(isUndefined)

  abovePlusAux(s:Set(Floor)) : Set(Floor) = 
    if s->collect(floor|floor.above)->exists(floor|s->excludes(floor))
    then abovePlusAux(s->union(s->collect(floor|floor.above))->asSet)
    else s
    endif

  belowPlusAux(s:Set(Floor)) : Set(Floor) =
    if s->collect(floor|floor.below)->exists(floor|s->excludes(floor))
    then belowPlusAux(s->union(s->collect(floor|floor.below))->asSet)
    else s
    endif
end

class Elevator < Location
attributes
  z : Real
  v : Real
  maxLoad : Real
  beeping : Boolean
  direction : Direction
  brake : Boolean
end

enum Direction {idle, up, down}

class Person
attributes
  weight : Real
end

enum DoorsState {closed, open, closing, opening}
enum DoorsCommand {close, open}

-- associations

association FloorOrder between
  Floor[0..1] role below
  Floor[0..1] role above
end

associationclass Doors
between
  Floor[1..*] role floor
  Elevator[1..*] role elevator
attributes
  state : DoorsState
  command : DoorsCommand
end

associationclass FloorButton
between
  Elevator[1..*] role inElevator
  Floor[1..*] role destFloor
attributes
  pressed : Boolean
end

associationclass UpButton
between
  Floor[1..*] role upOnFloor
  Elevator[*] role upToElevator
attributes
  pressed : Boolean
end

associationclass DownButton
between
  Floor[1..*] role downOnFloor
  Elevator[*] role downToElevator
attributes
  pressed : Boolean
end

aggregation CurrentLocation
between
  Location[1] role location
  Person[*] role person
end

-- constraints

constraints

-- put your constraints here

-- Invariant 1
-- Floors must be fitted without gaps, i.e., the coordinate z of the floor above
-- must be equal to the coordinate z of the floor below plus its height.

context Floor
inv: (self.below->notEmpty()) implies self.z = self.below.z + self.below.height 
      and (self.above->notEmpty()) implies self.above.z = self.z+self.height

-- Invariant 2
-- FloorOrder, when transitively closed, must form a strict order,
-- i.e. be irreflexive and asymmetric.

context Floor
inv: self.above <> self and self.below <> self and self.above <> self.below

-- Invariant 3
-- Floors must form a single chain.

-- context Floor
-- inv: if (self.below->notEmpty()) then self.below->size()=1 and self.below.above = self else self.below->size()=0 endif 
--      and if (self.above->notEmpty()) then self.above->size()=1 and self.above.below= self else self.above->size()=0 endif
--      and if (self.below->notEmpty() and self.above->notEmpty()) then self.below = self.above.below.below 
--      and self.above = self.below.above.above 
--      else self.below->size()=0 or self.above->size()=0 endif

context Floor
inv: Floor.allInstances()->one(f|f.above->size()=0) and Floor.allInstances()->one(f|f.below->size()=0)

-- Invariant 4
-- Doors can open only if the Elevator is in the deltaZ-neighborhood of some Floor,
-- the brake is set, and the Elevator is not beeping.

context Doors
inv: let deltaZ:Real =  Controller.allInstances()->asSequence()->first().deltaZ in
(self.state=DoorsState::open or self.state=DoorsState::opening or self.state=DoorsState::closing) implies
((self.elevator.z-self.floor.z).abs()<=deltaZ and
self.elevator.brake=true and self.elevator.beeping=false) 

-- Invariant 5
-- Elevator must be beeping iff the weight of the passengers inside
-- the Elevator is greater than its maxLoad.

context Elevator
inv: if (self.person.weight->sum() > self.maxLoad) then (self.beeping = true)
else (self.beeping = false) endif

-- Invariant 6
-- Elevatorâ€™s coordinate z must be either between Floors or in their deltaZ-neighborhoods.
context Elevator

inv: let deltaZ:Real =  Controller.allInstances()->asSequence()->first().deltaZ in
if (self.floor->asSequence()->first().abovePlus()->notEmpty())
then not self.floor->asSequence()->first().abovePlus()->forAll(f:Floor|self.z>f.z+deltaZ)
else self.z<=self.floor->asSequence()->first().z+deltaZ endif
and if (self.floor->asSequence()->first().belowPlus()->notEmpty())
then not self.floor->asSequence()->first().belowPlus()->forAll(f:Floor|self.z<f.z-deltaZ)
else self.z>=self.floor->asSequence()->first().z-deltaZ endif
-- end model
